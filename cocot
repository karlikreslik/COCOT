////////////////////////////////////////////////////////////
//COCOT - C Code Editor, Designed by Karel Resl, 30.09.2025
//Compilation: gcc cocot.c -o cocot -lncurses
////////////////////////////////////////////////////////////

#define _GNU_SOURCE
#include <ncurses.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/stat.h>
#include <pwd.h>

#define MAX_TEXT 50000
#define TAB_SIZE 4
#define LINE_NUM_WIDTH 6


// Control keys
#define CTRL_S 19
#define CTRL_N 14
#define CTRL_O 15
#define CTRL_X 24
#define CTRL_Q 17
#define CTRL_F 6
#define CTRL_G 7
#define CTRL_H 8
#define CTRL_D 4
#define CTRL_Z 26
#define CTRL_L 12

char current_filename[512] = "";
int modified = 0;
char search_term[256] = "";
int search_highlight_pos = -1;
int dark_theme = 1;


// Enhanced C keywords
const char *c_keywords[] = {
    "auto", "break", "case", "char", "const", "continue", "default", "do", 
    "double", "else", "enum", "extern", "float", "for", "goto", "if", 
    "int", "long", "register", "return", "short", "signed", "sizeof", "static", 
    "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while",
    "bool", "true", "false", "NULL", "_Bool", "_Complex", "_Imaginary",
    "inline", "restrict", "_Alignas", "_Alignof", "_Atomic", "_Generic", "_Noreturn",
    "_Static_assert", "_Thread_local"
};
const int num_keywords = 48;

// Preprocessor directives
const char *preprocessor_directives[] = {
    "#include", "#define", "#ifdef", "#ifndef", "#if", "#else", "#elif", "#endif", 
    "#undef", "#pragma", "#error", "#warning", "#line"
};
const int num_directives = 13;

// Common C functions
const char *c_functions[] = {
    "printf", "scanf", "malloc", "free", "calloc", "realloc", "strlen", "strcpy", 
    "strcmp", "strcat", "strncpy", "strncmp", "strncat", "memset", "memcpy",
    "memmove", "memcmp", "strchr", "strrchr", "strstr", "strtok", "atoi", "atof",
    "atol", "atoll", "fopen", "fclose", "fread", "fwrite", "fprintf", "fscanf",
    "fgets", "fputs", "getchar", "putchar", "gets", "puts", "sprintf", "sscanf",
    "exit", "abort", "system", "qsort", "bsearch", "time", "clock", "rand", "srand"
};
const int num_functions = 48;

// Common C types and structures
const char *c_types[] = {
    "size_t", "ssize_t", "FILE", "NULL", "stdin", "stdout", "stderr",
    "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t",
    "intptr_t", "uintptr_t", "ptrdiff_t", "clock_t", "time_t", "wchar_t",
    "intmax_t", "uintmax_t", "int_fast8_t", "int_fast16_t", "int_fast32_t", "int_fast64_t",
    "uint_fast8_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t"
};
const int num_types = 32;

// C standard library headers
const char *c_headers[] = {
    "stdio.h", "stdlib.h", "string.h", "ctype.h", "math.h", "time.h",
    "unistd.h", "fcntl.h", "sys/types.h", "sys/stat.h", "dirent.h",
    "errno.h", "signal.h", "setjmp.h", "assert.h", "limits.h", "float.h",
    "stddef.h", "locale.h", "wchar.h", "wctype.h", "stdarg.h", "stdbool.h",
    "stdint.h", "inttypes.h", "tgmath.h", "complex.h", "fenv.h", "stdalign.h",
    "stdatomic.h", "stdnoreturn.h", "threads.h", "uchar.h"
};
const int num_headers = 33;

// Common C macros and constants
const char *c_macros[] = {
    "NULL", "EOF", "BUFSIZ", "FILENAME_MAX", "FOPEN_MAX", "L_tmpnam",
    "SEEK_CUR", "SEEK_END", "SEEK_SET", "TMP_MAX", "stdin", "stdout", "stderr",
    "EXIT_SUCCESS", "EXIT_FAILURE", "RAND_MAX", "MB_CUR_MAX"
};
const int num_macros = 17;

int is_keyword(const char *word, int length) {
    for (int i = 0; i < num_keywords; i++) {
        if (strlen(c_keywords[i]) == length && 
            strncmp(word, c_keywords[i], length) == 0) {
            return 1;
        }
    }
    return 0;
}

int is_function(const char *word, int length) {
    for (int i = 0; i < num_functions; i++) {
        if (strlen(c_functions[i]) == length && 
            strncmp(word, c_functions[i], length) == 0) {
            return 1;
        }
    }
    return 0;
}

int is_directive(const char *line_start) {
    while (*line_start == ' ' || *line_start == '\t') {
        line_start++;
    }
    
    if (*line_start != '#') {
        return 0;
    }
    
    const char *directive_start = line_start + 1;
    const char *directive_end = directive_start;
    while (*directive_end && !isspace(*directive_end) && *directive_end != '\n') {
        directive_end++;
    }
    
    int directive_length = directive_end - directive_start;
    
    for (int i = 0; i < num_directives; i++) {
        if (strlen(preprocessor_directives[i] + 1) == directive_length && 
            strncmp(directive_start, preprocessor_directives[i] + 1, directive_length) == 0) {
            return 1;
        }
    }
    return 0;
}

int count_words(const char *text) {
    if (!text || !*text) return 0;
    int count = 0, in_word = 0;
    for (int i = 0; text[i]; i++) {
        if (isspace(text[i])) {
            in_word = 0;
        } else if (!in_word) {
            in_word = 1;
            count++;
        }
    }
    return count;
}

int count_lines(const char *text, int len) {
    if (len == 0) return 1;
    int lines = 1;
    for (int i = 0; i < len; i++) {
        if (text[i] == '\n') lines++;
    }
    return lines;
}

int save_file(const char *filename, const char *text) {
    FILE *f = fopen(filename, "w");
    if (!f) return 0;
    fprintf(f, "%s", text);
    fclose(f);
    return 1;
}

int load_file(const char *filename, char *text, int max_size) {
    FILE *f = fopen(filename, "r");
    if (!f) return 0;
    int len = fread(text, 1, max_size - 1, f);
    text[len] = '\0';
    fclose(f);
    return len;
}

void show_message(const char *message, int duration_ms) {
    attron(COLOR_PAIR(11) | A_BOLD);
    mvprintw(LINES - 1, 0, " %s", message);
    clrtoeol();
    attroff(COLOR_PAIR(11) | A_BOLD);
    refresh();
    if (duration_ms > 0) {
        napms(duration_ms);
    }
}

int get_filename_input(char *filename, int max_len, const char *prompt) {
    echo();
    curs_set(1);
    
    char *home_dir = getenv("HOME");
    if (!home_dir) {
        struct passwd *pw = getpwuid(getuid());
        home_dir = pw ? pw->pw_dir : "/tmp";
    }
    
    attron(COLOR_PAIR(11) | A_BOLD);
    mvprintw(LINES - 1, 0, " %s: ", prompt);
    clrtoeol();
    attroff(COLOR_PAIR(11) | A_BOLD);
    refresh();
    
    char basename[200] = "";
    int result = getnstr(basename, sizeof(basename) - 1);
    
    noecho();
    curs_set(1);
    
    if (result == ERR) {
        return 0;
    }
    
    if (strlen(basename) > 0) {
        char *dot = strrchr(basename, '.');
        if (dot && strcmp(dot, ".c") == 0) {
            *dot = '\0';
        }
        snprintf(filename, max_len, "%s/%s.c", home_dir, basename);
    } else {
        snprintf(filename, max_len, "%s/untitled.c", home_dir);
    }
    
    return 1;
}

int search_text(const char *text, int len, const char *search, int start_pos) {
    if (!search || !*search) return -1;
    
    int search_len = strlen(search);
    for (int i = start_pos; i <= len - search_len; i++) {
        if (strncmp(&text[i], search, search_len) == 0) {
            return i;
        }
    }
    return -1;
}

void duplicate_line(char *text, int *len, int *pos) {
    if (*len >= MAX_TEXT - 100) return;
    
    int line_start = *pos;
    while (line_start > 0 && text[line_start-1] != '\n') line_start--;
    
    int line_end = *pos;
    while (line_end < *len && text[line_end] != '\n') line_end++;
    
    int line_length = line_end - line_start;
    
    if (*len + line_length + 1 < MAX_TEXT) {
        memmove(&text[line_end + line_length + 1], &text[line_end], *len - line_end + 1);
        text[line_end] = '\n';
        memcpy(&text[line_end + 1], &text[line_start], line_length);
        *len += line_length + 1;
        *pos = line_end + line_length + 1;
    }
}

void init_color_scheme(int dark_mode) {
    if (!has_colors()) return;
    
    if (dark_mode) {
        // Dark theme (Blue Design)
        init_pair(1, COLOR_WHITE, COLOR_BLACK);      // Default text
        init_pair(2, COLOR_CYAN, COLOR_BLACK);      // Line numbers
        init_pair(3, COLOR_MAGENTA, COLOR_BLACK);    // Keywords
        init_pair(4, COLOR_GREEN, COLOR_BLACK);      // Strings
        init_pair(5, COLOR_YELLOW, COLOR_BLACK);     // Preprocessor
        init_pair(6, COLOR_CYAN, COLOR_BLACK);       // Functions
        init_pair(7, COLOR_RED, COLOR_BLACK);        // Numbers
        init_pair(8, COLOR_BLUE, COLOR_BLACK);       // Comments
        init_pair(9, COLOR_WHITE, COLOR_BLACK);      // Operators
        init_pair(10, COLOR_YELLOW, COLOR_BLACK);    // Types
        init_pair(11, COLOR_WHITE, COLOR_BLUE);      // Status bar (The main blue color)
        init_pair(12, COLOR_BLACK, COLOR_YELLOW);    // Search highlight
        // Autocomplete color pairs (13 and 14) removed
    } else {
        // Light theme (Kept but not default)
        init_pair(1, COLOR_BLACK, COLOR_WHITE);      // Default text
        init_pair(2, COLOR_BLUE, COLOR_WHITE);       // Line numbers
        init_pair(3, COLOR_RED, COLOR_WHITE);        // Keywords
        init_pair(4, COLOR_GREEN, COLOR_WHITE);      // Strings
        init_pair(5, COLOR_MAGENTA, COLOR_WHITE);    // Preprocessor
        init_pair(6, COLOR_BLUE, COLOR_WHITE);       // Functions
        init_pair(7, COLOR_RED, COLOR_WHITE);        // Numbers
        init_pair(8, COLOR_BLUE, COLOR_WHITE);       // Comments
        init_pair(9, COLOR_BLACK, COLOR_WHITE);      // Operators
        init_pair(10, COLOR_MAGENTA, COLOR_WHITE);   // Types
        init_pair(11, COLOR_BLACK, COLOR_CYAN);      // Status bar
        init_pair(12, COLOR_WHITE, COLOR_RED);       // Search highlight
        
    }
    
    bkgd(COLOR_PAIR(1));
}

int main() {
    char text[MAX_TEXT] = "";
    int len = 0;
    int pos = 0;
    int ch;
    int running = 1;
    int scroll_offset = 0;
    
    initscr();
    raw();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(1);
    
    if (has_colors()) {
        start_color();
        use_default_colors();
        init_color_scheme(dark_theme);
    }
    
    clear();
    refresh();
    
    while (running) {
        erase();
        
        // Header
        attron(COLOR_PAIR(11));
        move(0, 0);
        for (int i = 0; i < COLS; i++) addch(' ');
        
        if (strlen(current_filename) > 0) {
            char *basename = strrchr(current_filename, '/');
            basename = basename ? basename + 1 : current_filename;
            mvprintw(0, 2, "%s%s", basename, modified ? " *" : "");
        } else {
            mvprintw(0, 2, "untitled%s", modified ? " *" : "");
        }
        attroff(COLOR_PAIR(11));
        
        int current_line = 1;
        for (int i = 0; i < pos; i++) {
            if (text[i] == '\n') current_line++;
        }
        
        int visible_lines = LINES - 3;
        if (current_line < scroll_offset + 1) {
            scroll_offset = current_line - 1;
        } else if (current_line > scroll_offset + visible_lines) {
            scroll_offset = current_line - visible_lines;
        }
        if (scroll_offset < 0) scroll_offset = 0;
        
        // Display text 
        int display_line = 1;
        int y = 1;
        int text_pos = 0;
        
        while (text_pos < len && display_line <= scroll_offset) {
            if (text[text_pos] == '\n') display_line++;
            text_pos++;
        }
        
        while (y < LINES - 1 && text_pos <= len && display_line <= scroll_offset + visible_lines) {
            attron(COLOR_PAIR(2));
            if (display_line == current_line) {
                attron(A_BOLD);
                mvprintw(y, 0, " %4d ", display_line);
                attroff(A_BOLD);
            } else {
                mvprintw(y, 0, " %4d ", display_line);
            }
            attroff(COLOR_PAIR(2));
            
            int x = LINE_NUM_WIDTH;
            int line_start = text_pos;
            int in_comment = 0;
            int in_string = 0;
            int in_char = 0;
            char string_char = 0;
            
            while (text_pos < len && text[text_pos] != '\n' && x < COLS - 1) {
                int is_search_match = 0;
                if (search_term[0] && text_pos == search_highlight_pos) {
                    is_search_match = 1;
                    attron(COLOR_PAIR(12) | A_BOLD);
                }
                
                if (text[text_pos] == '\t') {
                    int spaces = TAB_SIZE - ((x - LINE_NUM_WIDTH) % TAB_SIZE);
                    for (int i = 0; i < spaces && x < COLS - 1; i++) {
                        mvaddch(y, x++, ' ');
                    }
                    text_pos++;
                } else {
                    if (!in_comment && !in_string && !in_char) {
                        if (text[text_pos] == '"') {
                            in_string = 1;
                            string_char = '"';
                            attron(COLOR_PAIR(4));
                            mvaddch(y, x++, text[text_pos]);
                            text_pos++;
                            continue;
                        } else if (text[text_pos] == '\'') {
                            in_char = 1;
                            string_char = '\'';
                            attron(COLOR_PAIR(4));
                            mvaddch(y, x++, text[text_pos]);
                            text_pos++;
                            continue;
                        } else if (text_pos + 1 < len && text[text_pos] == '/' && text[text_pos + 1] == '*') {
                            in_comment = 1;
                            attron(COLOR_PAIR(8) | A_DIM);
                        } else if (text_pos + 1 < len && text[text_pos] == '/' && text[text_pos + 1] == '/') {
                            attron(COLOR_PAIR(8) | A_DIM);
                            while (text_pos < len && text[text_pos] != '\n' && x < COLS - 1) {
                                if (text[text_pos] == '\t') {
                                    int spaces = TAB_SIZE - ((x - LINE_NUM_WIDTH) % TAB_SIZE);
                                    for (int i = 0; i < spaces && x < COLS - 1; i++) {
                                        mvaddch(y, x++, ' ');
                                    }
                                } else {
                                    mvaddch(y, x++, text[text_pos]);
                                }
                                text_pos++;
                            }
                            attroff(COLOR_PAIR(8) | A_DIM);
                            continue;
                        } else if (is_directive(&text[line_start])) {
                            attron(COLOR_PAIR(5));
                            while (text_pos < len && text[text_pos] != '\n' && x < COLS - 1) {
                                if (text[text_pos] == '\t') {
                                    int spaces = TAB_SIZE - ((x - LINE_NUM_WIDTH) % TAB_SIZE);
                                    for (int i = 0; i < spaces && x < COLS - 1; i++) {
                                        mvaddch(y, x++, ' ');
                                    }
                                } else {
                                    mvaddch(y, x++, text[text_pos]);
                                }
                                text_pos++;
                            }
                            attroff(COLOR_PAIR(5));
                            continue;
                        } else if (isalpha(text[text_pos]) || text[text_pos] == '_') {
                            int word_start = text_pos;
                            while (text_pos < len && (isalnum(text[text_pos]) || text[text_pos] == '_')) {
                                text_pos++;
                            }
                            int word_length = text_pos - word_start;
                            
                            int color_pair = 1;
                            if (is_keyword(&text[word_start], word_length)) {
                                color_pair = 3;
                            } else if (is_function(&text[word_start], word_length)) {
                                color_pair = 6;
                            } else {
                                color_pair = 1;
                            }
                            
                            attron(COLOR_PAIR(color_pair));
                            for (int i = word_start; i < text_pos; i++) {
                                if (x < COLS - 1) {
                                    mvaddch(y, x++, text[i]);
                                }
                            }
                            attroff(COLOR_PAIR(color_pair));
                            continue;
                        } else if (isdigit(text[text_pos])) {
                            attron(COLOR_PAIR(7));
                            mvaddch(y, x++, text[text_pos]);
                            attroff(COLOR_PAIR(7));
                            text_pos++;
                            continue;
                        } else if (strchr("+-*/%=<>!&|^~(){}[];:,.", text[text_pos])) {
                            attron(COLOR_PAIR(9));
                            mvaddch(y, x++, text[text_pos]);
                            attroff(COLOR_PAIR(9));
                            text_pos++;
                            continue;
                        } else {
                            attron(COLOR_PAIR(1));
                            mvaddch(y, x++, text[text_pos]);
                            attroff(COLOR_PAIR(1));
                            text_pos++;
                            continue;
                        }
                    } else if (in_comment) {
                        if (text_pos + 1 < len && text[text_pos] == '*' && text[text_pos + 1] == '/') {
                            mvaddch(y, x++, text[text_pos++]);
                            if (x < COLS - 1) {
                                mvaddch(y, x++, text[text_pos]);
                            }
                            in_comment = 0;
                            attroff(COLOR_PAIR(8) | A_DIM);
                        } else {
                            mvaddch(y, x++, text[text_pos]);
                        }
                        text_pos++;
                        continue;
                    } else if (in_string || in_char) {
                        if (text[text_pos] == '\\' && text_pos + 1 < len) {
                            mvaddch(y, x++, text[text_pos++]);
                            if (x < COLS - 1 && text_pos < len) {
                                mvaddch(y, x++, text[text_pos]);
                            }
                            text_pos++;
                            continue;
                        } else if (text[text_pos] == string_char) {
                            mvaddch(y, x++, text[text_pos]);
                            in_string = 0;
                            in_char = 0;
                            attroff(COLOR_PAIR(4));
                            text_pos++;
                            continue;
                        } else {
                            mvaddch(y, x++, text[text_pos]);
                            text_pos++;
                            continue;
                        }
                    }
                    
                    text_pos++;
                }
                
                if (is_search_match) {
                    attroff(COLOR_PAIR(12) | A_BOLD);
                }
            }
            
            if (text_pos < len && text[text_pos] == '\n') {
                text_pos++;
            }
            
            display_line++;
            y++;
        }
        
        // Calculate cursor position
        int cursor_line = 1;
        int cursor_col = 0;
        for (int i = 0; i < pos; i++) {
            if (text[i] == '\n') {
                cursor_line++;
                cursor_col = 0;
            } else if (text[i] == '\t') {
                cursor_col += TAB_SIZE - (cursor_col % TAB_SIZE);
            } else {
                cursor_col++;
            }
        }
        
        // Status bar
        attron(COLOR_PAIR(11));
        move(LINES - 1, 0);
        for (int i = 0; i < COLS; i++) addch(' ');
        
        char status[512];
        snprintf(status, sizeof(status), " Line %d/%d  Col %d  Words %d  %s", 
                 cursor_line, count_lines(text, len), cursor_col + 1, 
                 count_words(text), modified ? "*" : "");
        mvprintw(LINES - 1, 2, "%s", status);
        
        if (COLS > 60) {
            mvprintw(LINES - 1, COLS - 60, "^S Save  ^O Open  ^F Find  ^L Theme  ^D Dup  ^X Exit");
        }
        attroff(COLOR_PAIR(11));
        
        // Position cursor
        int screen_y = cursor_line - scroll_offset;
        int screen_x = LINE_NUM_WIDTH + cursor_col;
        
        if (screen_y >= 1 && screen_y < LINES - 1 && screen_x >= LINE_NUM_WIDTH && screen_x < COLS) {
            move(screen_y, screen_x);
        }
        refresh();
        
        ch = getch();
                
        switch (ch) {
            case CTRL_S:
                {
                    char temp_filename[512];
                    if (strlen(current_filename) == 0) {
                        if (get_filename_input(temp_filename, sizeof(temp_filename), "Save as")) {
                            strcpy(current_filename, temp_filename);
                        } else {
                            show_message("Save cancelled", 1000);
                            break;
                        }
                    } else {
                        strcpy(temp_filename, current_filename);
                    }
                    
                    if (save_file(temp_filename, text)) {
                        modified = 0;
                        show_message("File saved", 1000);
                    } else {
                        show_message("Error saving file", 2000);
                    }
                }
                break;
                
            case CTRL_N:
                if (modified) {
                    show_message("File modified! Press ^N again to discard changes", 0);
                    refresh();
                    int confirm = getch();
                    if (confirm != CTRL_N) break;
                }
                text[0] = '\0';
                len = 0;
                pos = 0;
                scroll_offset = 0;
                current_filename[0] = '\0';
                modified = 0;
                show_message("New file created", 1000);
                break;
                
            case CTRL_O:
                {
                    if (modified) {
                        show_message("File modified! Press ^O again to discard changes", 0);
                        refresh();
                        int confirm = getch();
                        if (confirm != CTRL_O) break;
                    }
                    
                    char filename[512];
                    if (get_filename_input(filename, sizeof(filename), "Open file")) {
                        int new_len = load_file(filename, text, MAX_TEXT);
                        if (new_len >= 0) {
                            len = new_len;
                            pos = 0;
                            scroll_offset = 0;
                            strcpy(current_filename, filename);
                            modified = 0;
                            show_message("File loaded", 1000);
                        } else {
                            show_message("Error loading file", 2000);
                        }
                    } else {
                        show_message("Open cancelled", 1000);
                    }
                }
                break;
                
            case CTRL_X:
                if (modified) {
                    show_message("File modified! Press ^X again to exit without saving", 0);
                    refresh();
                    int confirm = getch();
                    if (confirm == CTRL_X) running = 0;
                } else {
                    running = 0;
                }
                break;
                
            case CTRL_L:
                dark_theme = 1 - dark_theme;
                init_color_scheme(dark_theme);
                show_message(dark_theme ? "Dark Theme Activated" : "Light Theme Activated", 1000);
                break;
                
            case CTRL_F:
                {
                    echo();
                    curs_set(1);
                    attron(COLOR_PAIR(11) | A_BOLD);
                    mvprintw(LINES - 1, 0, " Search: ");
                    clrtoeol();
                    attroff(COLOR_PAIR(11) | A_BOLD);
                    refresh();
                    
                    search_term[0] = '\0';
                    getnstr(search_term, sizeof(search_term) - 1);
                    
                    noecho();
                    curs_set(1);
                    
                    search_highlight_pos = search_text(text, len, search_term, pos);
                    if (search_highlight_pos != -1) {
                        int current_pos_backup = pos;
                        pos = search_highlight_pos; // Move cursor to highlight position for scrolling calculation
                        
                        // Recalculate cursor line to ensure screen scrolls to show the match
                        int match_line = 1;
                        for (int i = 0; i < pos; i++) {
                            if (text[i] == '\n') match_line++;
                        }
                        
                        // Force scroll_offset adjustment
                        if (match_line < scroll_offset + 1 || match_line > scroll_offset + (LINES - 3)) {
                            scroll_offset = match_line - (LINES - 3) / 2;
                            if (scroll_offset < 0) scroll_offset = 0;
                        }
                        
                        pos = current_pos_backup; // Restore original cursor position (if not moving)
                        show_message("First match found (Ctrl+G to next)", 2000);
                    } else {
                        search_highlight_pos = -1;
                        search_term[0] = '\0';
                        show_message("Search term not found", 2000);
                    }
                }
                break;
                
            case CTRL_G:
                {
                    if (search_term[0]) {
                        int start_search_pos = search_highlight_pos + 1;
                        if (start_search_pos > len) start_search_pos = 0;
                        
                        int next_match = search_text(text, len, search_term, start_search_pos);
                        if (next_match != -1) {
                            search_highlight_pos = next_match;
                            int current_pos_backup = pos;
                            pos = search_highlight_pos;
                            
                            int match_line = 1;
                            for (int i = 0; i < pos; i++) {
                                if (text[i] == '\n') match_line++;
                            }
                            
                            if (match_line < scroll_offset + 1 || match_line > scroll_offset + (LINES - 3)) {
                                scroll_offset = match_line - (LINES - 3) / 2;
                                if (scroll_offset < 0) scroll_offset = 0;
                            }
                            
                            pos = current_pos_backup;
                            show_message("Next match found", 1000);
                        } else {
                            show_message("No more matches found", 2000);
                        }
                    }
                }
                break;
                
            case CTRL_D:
                duplicate_line(text, &len, &pos);
                modified = 1;
                break;
                
            case KEY_UP:
                {
                    if (pos == 0) break;
                    
                    int line_start = pos;
                    while (line_start > 0 && text[line_start-1] != '\n') line_start--;
                    
                    if (line_start == 0) {
                        pos = 0;
                    } else {
                        int prev_line_end = line_start - 1;
                        int prev_line_start = prev_line_end;
                        while (prev_line_start > 0 && text[prev_line_start-1] != '\n') prev_line_start--;
                        
                        int col = 0;
                        for (int i = line_start; i < pos; i++) {
                            if (text[i] == '\t') col += TAB_SIZE - (col % TAB_SIZE);
                            else col++;
                        }
                        
                        int prev_col = 0;
                        int target_pos = prev_line_start;
                        for (int i = prev_line_start; i < prev_line_end; i++) {
                            int next_col = prev_col;
                            if (text[i] == '\t') next_col += TAB_SIZE - (next_col % TAB_SIZE);
                            else next_col++;
                            
                            if (next_col > col) break;
                            
                            prev_col = next_col;
                            target_pos = i + 1;
                        }
                        pos = target_pos;
                    }
                }
                break;
                
            case KEY_DOWN:
                {
                    int line_end = pos;
                    while (line_end < len && text[line_end] != '\n') line_end++;
                    
                    if (line_end == len) break;
                    
                    int line_start = pos;
                    while (line_start > 0 && text[line_start-1] != '\n') line_start--;
                    
                    int col = 0;
                    for (int i = line_start; i < pos; i++) {
                        if (text[i] == '\t') col += TAB_SIZE - (col % TAB_SIZE);
                        else col++;
                    }
                    
                    int next_line_start = line_end + 1;
                    int next_line_end = next_line_start;
                    while (next_line_end < len && text[next_line_end] != '\n') next_line_end++;
                    
                    int next_col = 0;
                    int target_pos = next_line_start;
                    for (int i = next_line_start; i < next_line_end; i++) {
                        int current_col_view = next_col;
                        if (text[i] == '\t') current_col_view += TAB_SIZE - (current_col_view % TAB_SIZE);
                        else current_col_view++;
                        
                        if (current_col_view > col) break;
                        
                        next_col = current_col_view;
                        target_pos = i + 1;
                    }
                    pos = target_pos;
                }
                break;
                
            case KEY_LEFT:
                if (pos > 0) pos--;
                break;
                
            case KEY_RIGHT:
                if (pos < len) pos++;
                break;
                
            case KEY_HOME:
                {
                    int line_start = pos;
                    while (line_start > 0 && text[line_start-1] != '\n') line_start--;
                    pos = line_start;
                }
                break;
                
            case KEY_END:
                {
                    int line_end = pos;
                    while (line_end < len && text[line_end] != '\n') line_end++;
                    pos = line_end;
                }
                break;
                
            case '\t':
                if (len + TAB_SIZE < MAX_TEXT) {
                    memmove(&text[pos + TAB_SIZE], &text[pos], len - pos + 1);
                    for (int i = 0; i < TAB_SIZE; i++) {
                        text[pos + i] = ' ';
                    }
                    pos += TAB_SIZE;
                    len += TAB_SIZE;
                    modified = 1;
                }
                break;
                
            case '\n':
            case '\r':
                {
                    if (len < MAX_TEXT - 1) {
                        int line_start = pos;
                        while (line_start > 0 && text[line_start-1] != '\n') line_start--;
                        
                        int indentation = 0;
                        for (int i = line_start; i < pos; i++) {
                            if (text[i] == ' ' || text[i] == '\t') {
                                indentation++;
                            } else {
                                indentation = 0;
                            }
                        }
                        
                        // Insert newline
                        memmove(&text[pos + 1], &text[pos], len - pos + 1);
                        text[pos] = '\n';
                        len++;
                        pos++;
                        
                        // Insert auto-indentation
                        if (len + indentation < MAX_TEXT) {
                            memmove(&text[pos + indentation], &text[pos], len - pos + 1);
                            for (int i = 0; i < indentation; i++) {
                                text[pos + i] = ' ';
                            }
                            pos += indentation;
                            len += indentation;
                        }
                        
                        modified = 1;
                    }
                }
                break;
                
            case 127: // Backspace
            case KEY_BACKSPACE:
            case CTRL_H:
                if (pos > 0) {
                    if (pos >= TAB_SIZE && strncmp(&text[pos - TAB_SIZE], "    ", TAB_SIZE) == 0) {
                         // Tab deletion (4 spaces)
                        memmove(&text[pos - TAB_SIZE], &text[pos], len - pos + 1);
                        pos -= TAB_SIZE;
                        len -= TAB_SIZE;
                    } else {
                        // Single char deletion
                        memmove(&text[pos - 1], &text[pos], len - pos + 1);
                        pos--;
                        len--;
                    }
                    modified = 1;
                }
                break;
                
            case KEY_DC: // Delete
                if (pos < len) {
                    memmove(&text[pos], &text[pos + 1], len - pos);
                    len--;
                    modified = 1;
                }
                break;
                
            default:
                if (isprint(ch) && len < MAX_TEXT - 1) {
                    memmove(&text[pos + 1], &text[pos], len - pos + 1);
                    text[pos] = (char)ch;
                    pos++;
                    len++;
                    modified = 1;
                    
                }
                break;
        }
    }
    
    endwin();
    return 0;
}
